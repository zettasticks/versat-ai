#include "versat_private.h"

#include <math.h>
#include <stdbool.h>
#include <stdint.h>

#define exit(...) ((void)0)
void clear_cache();

#define MIN(A, B) ((A < B ? A : B))
#define MAX(A, B) ((A > B ? A : B))

// Care when using this, when not debugging this just crashes the program
#define DEBUG_BREAK() __asm__("int3")

void *Software_ConvWithBias(void *inputX, void *inputW, void *inputB,
                            void *output, int index, ConvInfo *info) {
  int batchSize = info->inputDims[0];
  int inChannels = info->inputDims[1];
  int inW = info->inputDims[3];
  int inH = info->inputDims[2];

  int strideW = info->strideDims[1];
  int strideH = info->strideDims[0];

  int featureMaps = info->featureMaps;

  int kernelW = info->kernelDims[1];
  int kernelH = info->kernelDims[0];

  int group = info->group;

  int outChannels = info->outputDims[1]; // Should be equal to feature maps.
  int outW = info->outputDims[3];
  int outH = info->outputDims[2];

  float *input = (float *)inputX;
  float *kernel = (float *)inputW;
  float *bias = (float *)inputB;
  float *outView = (float *)output;

  ExtraInfo extra = CalculateExtraInfo_Conv(info);

  AddressGen outGenInst =
      StartAddress(info->outputDims, info->outputDims, info->dims);
  AddressGen *outGen = &outGenInst;

  // We probably want to move this to the array generated by python.
  // Emit the proper array directly
  int stride[MAX_DIMS];
  stride[0] = 1;
  stride[1] = 1;
  for (int i = 0; i < info->strideSize; i++) {
    stride[i + 2] = info->strideDims[i];
  }

  int offset[MAX_DIMS];
  offset[0] = 0;
  offset[1] = 0;
  offset[2] = extra.leftPadH;
  offset[3] = extra.leftPadW;

  int inputSize = inW * inH * inChannels;
  int outputSize = outW * outH * outChannels;

  float *inputView = input; // + (batch * inputSize);

  for (; Address_IsValid(outGen); Address_Advance(outGen)) {
    int outPos = Address_GetValue(outGen);

    AddressGen inputPos = Address_Map2(outGen, info->inputDims, stride, offset);

    // KernelGen does not know about the indexes used to access the kernel
    // weights We compute them outside.
    int outC = outGen->addressVars[1];

    float accum = 0.0f;
    KernelGen kernInst = StartKernel(&inputPos, info->kernelDims, 2);
    KernelGen *kern = &kernInst;

    int inChannelsPerGroup = inChannels / group;
    int outChannelsPerGroup = outChannels / group;

    if (group == 1) {
      kern->addressGenVars[1] = 0;
    } else {
      kern->addressGenVars[1] =
          (outC / outChannelsPerGroup) * inChannelsPerGroup;
    }
    kern->kernelDims[1] = inChannels / group;

    int currentGroup = outC / outChannelsPerGroup;
    for (int inC = currentGroup * inChannelsPerGroup;
         inC < (currentGroup + 1) * inChannelsPerGroup; inC++) {
      int kernelIndex =
          outC * (inChannels / group) * extra.kernelW * extra.kernelH;

      for (; Kernel_IsValid(kern); Kernel_Advance(kern), kernelIndex += 1) {
        bool isPadded = Kernel_IsInsidePad(kern);
        if (isPadded) {
          continue;
        }
        int index = Kernel_GetValue(kern);

        float kernelVal = kernel[kernelIndex];
        float inputVal = inputView[index];
        accum += inputVal * kernelVal;
      }
    }

    if (bias) {
      outView[outPos] = accum + bias[outC];
    } else {
      outView[outPos] = accum;
    }
  }

  return output;
}

void *Software_Conv(void *inputX, void *inputW, void *output, int index,
                    ConvInfo *info) {
  return Software_ConvWithBias(inputX, inputW, NULL, output, index, info);
}

void *Software_Reshape(void *data, void *shape, void *output, int index,
                       ReshapeInfo *info) {
  return data;
}

void *Software_Transpose(void *data, void *output, int index,
                         TransposeInfo *info) {
  int64_t *perms = (int64_t *)info->perm;

  int64_t outDims[MAX_DIMS] = {};

  for (int i = 0; i < info->numberInputDims; i++) {
    int index = info->perm[i];
    outDims[i] = info->inputDims[index];
  }

  AddressGen in =
      StartAddress(info->inputDims, info->inputDims, info->numberInputDims);
  AddressGen out = StartAddress(outDims, outDims, info->numberInputDims);

  float *inView = (float *)data;
  float *outView = (float *)output;

  for (; Address_IsValid(&in); Address_Advance(&in)) {
    int inAddr = Address_GetValue(&in);

    for (int i = 0; i < info->numberInputDims; i++) {
      int index = info->perm[i];
      out.addressVars[i] = in.addressVars[index];
    }

    int outAddr = Address_GetValue(&out);

    outView[outAddr] = inView[inAddr];
  }

  return output;
}

void *Software_Add(void *inputA, void *inputB, void *output, int index,
                   AddInfo *info) {
  float *viewA = (float *)inputA;
  float *viewB = (float *)inputB;
  float *out = (float *)output;

  // TODO: Instead of stuffing addressGen with the broadcasting stuff, we could
  // just iterate the broadcasted shape and call a function that would return
  // the proper index for the non broadcasted shape.
  //       Basically pull out all the properDim logic from address gen into a
  //       extra function.

  AddressGen inA =
      StartAddress(info->broadCastedShape, info->firstInputDim, info->maxDims);
  AddressGen inB =
      StartAddress(info->broadCastedShape, info->secondInputDim, info->maxDims);
  AddressGen outGen = StartAddress(info->broadCastedShape,
                                   info->broadCastedShape, info->maxDims);

  while (Address_IsValid(&outGen)) {
    int indexA = Address_GetValue(&inA);
    int indexB = Address_GetValue(&inB);
    int indexO = Address_GetValue(&outGen);

    Address_Advance(&inA);
    Address_Advance(&inB);
    Address_Advance(&outGen);

    float valA = viewA[indexA];
    float valB = viewB[indexB];

    out[indexO] = valA + valB;
  }

  return output;
}

void *Software_Relu(void *inputX, void *output, int index, ReluInfo *info) {
  float *view = (float *)inputX;
  float *out = (float *)output;

  int64_t totalSize = CalculateSizeOfDim(info->inputDims, info->dims);

  for (int64_t i = 0; i < totalSize; i++) {
    float val = view[i];
    out[i] = MAX(0.0f, val);
  }

  return output;
}

#if 0

// First need to generate the addresses that we care about, including padding and such.
// Generate from the perspective of the output.

#endif

void *Software_MaxPool(void *inputX, void *output, int index,
                       MaxPoolInfo *info) {
  float *view = (float *)inputX;
  float *out = (float *)output;

  ExtraInfo extra = CalculateExtraInfo_MaxPool(info);

  AddressGen outGenInst =
      StartAddress(info->outputDims, info->outputDims, info->dims);
  AddressGen *outGen = &outGenInst;

  // We probably want to move this to the array generated by python.
  // Emit the proper array directly
  int stride[MAX_DIMS];
  stride[0] = 1;
  stride[1] = 1;
  for (int i = 0; i < info->strideSize; i++) {
    stride[i + 2] = info->strideDims[i];
  }

  int offset[MAX_DIMS];
  offset[0] = 0;
  offset[1] = 0;
  offset[2] = extra.leftPadH;
  offset[3] = extra.leftPadW;

  // MARK
  for (; Address_IsValid(outGen); Address_Advance(outGen)) {
    float max = 0.0f;
    bool firstSet = false;

    AddressGen inputPos = Address_Map2(outGen, info->inputDims, stride, offset);
    KernelGen kernInst = StartKernel(&inputPos, info->kernelDims, 2);
    KernelGen *kern = &kernInst;

    for (; Kernel_IsValid(kern); Kernel_Advance(kern)) {
      bool isPadded = Kernel_IsInsidePad(kern);
      if (isPadded) {
        continue;
      }
      int index = Kernel_GetValue(kern);

      float val = view[index];

      // NOTE: Padding should never affect the output value.
      //       Because negative values exist, we cannot just use zero to
      //       represent a padded value. We might get away with using -inf, but
      //       for now we just use an extra flag to check validity.
      if (!firstSet) {
        max = val;
        firstSet = true;
      } else {
        max = MAX(max, val);
      }
    }

    int outputIndex = Address_GetValue(outGen);
    out[outputIndex] = max;
  }

  return output;
}

// NOTE: Basically a copy of MaxPool but changed to calculate the average at the
// end.
void *Software_AveragePool(void *inputX, void *output, int index,
                           AveragePoolInfo *info) {
  float *view = (float *)inputX;
  float *out = (float *)output;

  ExtraInfo extra = CalculateExtraInfo_AveragePool(info);

  AddressGen outGenInst =
      StartAddress(info->outputDims, info->outputDims, info->dims);
  AddressGen *outGen = &outGenInst;

  // We probably want to move this to the array generated by python.
  // Emit the proper array directly
  int stride[MAX_DIMS];
  stride[0] = 1;
  stride[1] = 1;
  for (int i = 0; i < info->strideSize; i++) {
    stride[i + 2] = info->strideDims[i];
  }

  int offset[MAX_DIMS];
  offset[0] = 0;
  offset[1] = 0;
  offset[2] = extra.leftPadH;
  offset[3] = extra.leftPadW;

  for (; Address_IsValid(outGen); Address_Advance(outGen)) {
    float sum = 0.0f;
    float div = 0.0f;

    AddressGen inputPos = Address_Map2(outGen, info->inputDims, stride, offset);
    KernelGen kernInst = StartKernel(&inputPos, info->kernelDims, 2);
    KernelGen *kern = &kernInst;
    for (; Kernel_IsValid(kern); Kernel_Advance(kern)) {
      if (Kernel_IsInsidePad(kern)) {
        continue;
      }
      int index = Kernel_GetValue(kern);

      float val = view[index];

      sum += val;
      div += 1.0f;
    }

    int outputIndex = Address_GetValue(outGen);
    out[outputIndex] = (sum / div);
  }

  return output;
}

void *Software_MatMul(void *inputA, void *inputB, void *output, int index,
                      MatMulInfo *info) {
  float *viewA = (float *)inputA;
  float *viewB = (float *)inputB;
  float *viewOut = (float *)output;

  int AH = info->inputADims[0];
  int AW = info->inputADims[1];

  int BH = info->inputBDims[0];
  int BW = info->inputBDims[1];

  int OH = info->outputDims[0];
  int OW = info->outputDims[1];

  if (AW != BH) {
    versat_printf("Something very wrong is happening in MatMul\n");
  }

  for (int y = 0; y < OH; y++) {
    for (int x = 0; x < OW; x++) {
      int indexOut = y * OW + x;

      viewOut[indexOut] = 0.0f;
      for (int c = 0; c < AW; c++) {
        int indexA = y * AW + c;
        int indexB = c * BW + x;

        float valA = viewA[indexA];
        float valB = viewB[indexB];

        viewOut[indexOut] += valA * valB;
      }
    }
  }

  return output;
}

float ABS(float x) { return x < 0 ? -x : x; }

float my_exp(float x) {
  double result = 1.0;
  double term = 1.0;
  double div = 1.0;
  double dx = (double)x;
  int maxTerms = 100000; // Failsafe

  double lastResult = result;
  for (int n = 1; n < maxTerms; n++) {
    term *= dx / div;
    div += 1.0;
    result += term;

    // As term gets smaller eventually we will reach a point where addition does
    // not change anything
    if (lastResult == result) {
      break;
    }
    lastResult = result;
  }

  return (float)result;
}

void *Software_Softmax(void *input, void *output, int index,
                       SoftmaxInfo *info) {
  float sum = 0.0f;

  float *view = (float *)input;
  float *out = (float *)output;

  // Axis are normalized here, no need to handle negative axis after this point
  int axis = info->axis;
  if (axis < 0) {
    axis += info->numberInputDims;
  }

  /*
    The idea behind the softmax axis is that we separate dimensions into two
    regions One is the iteration region and the other is the value region. The
    axis is the separator and the dims to the right and including the axis are
    the value region. For an axis of 0, the value region is everything so we sum
    everything and calculate softmax. We do 1 sum in this mode. For an axis of
    1, the iteration region is a single loop and the rest is sum and used to
    calculate softmax. Note that if the iteration region contains a loop of size
    N we do N total sums. For an axis of 2 the iteration region is two loops. If
    we have loop of size N and M then we calculate N*M total sums. And so on.
  */

  // TODO: We probably can simplify the logic in here by using Dimensions.

  AddressGen testInst = StartAddress(info->inputDims, info->inputDims, info->numberInputDims);
  AddressGen *test = &testInst;

  int kernelSize = info->numberInputDims - axis;

  for (; Address_IsValid(test); Address_AdvanceAxis(test, axis - 1)) {
    int kernelDims[MAX_DIMS] = {};
    for (int i = 0; i < kernelSize; i++) {
      kernelDims[i] = info->inputDims[i + axis];
    }

    float sum = 0.0f;

    KernelGen genInst = StartKernel(test, kernelDims, kernelSize);
    KernelGen *gen = &genInst;
    for (; Kernel_IsValid(gen); Kernel_Advance(gen)) {
      int index = Kernel_GetValue(gen);

      sum += my_exp(view[index]);
    }

    genInst = StartKernel(test, kernelDims, kernelSize);
    for (; Kernel_IsValid(gen); Kernel_Advance(gen)) {
      int index = Kernel_GetValue(gen);

      out[index] = my_exp(view[index]) / sum;
    }
  }

  return output;
}

// TODO: While this is the approach that directly matches what ONNX requires, it is also slower for the average case. (Where the statistic values are usually initializers and not inputs.)
//       A lot of the logic can be simplified by precomputing values (ex: the invsqrt routine is not needed since it only cares about values that we already know about)
//       This of course can only be perform if the values are initializers and not inputs. (Which I assume is the default case for a great deal of these.)
//       That means there is a possibility of using a much faster routine by pushing logic to the onnx converter and have it collapse all the initializers into a simpler operation.
void *Software_BatchNormalization(void *inputX, void *scale, void *inputB,void *mean,void *var, void *output, int index,
                       BatchNormalizationInfo *info){

  float* x = (float*) inputX;
  float* s = (float*) scale;
  float* b = (float*) inputB;
  float* m = (float*) mean;
  float* v = (float*) var;
  float* o = (float*) output;

  Dimensions dim = CreateDimensions(info->inputDims,info->numberInputDims);

  if(dim.size <= 1){
    Dimensions_AppendInPlace(&dim,1);
  }

  AddressGen addrInst = StartAddressFromDims(dim,2);
  AddressGen* addr = &addrInst;

  // TODO: We probably can also do this using the Kernel stuff.
  //       But I kinda want a better interface when using kernel stuff.
  Dimensions leftover = Dimensions_Cut_GetRight(dim,2);
  int size = Dimensions_TotalSize(leftover);

  while(Address_IsValid(addr)){
    int c = Address_GetDim(addr,1);
    
    int index = Address_GetValue(addr);
    
    for(int i = 0; i < size; i++){
      o[index + i] = ((x[index + i] - m[c]) * my_invsqrt(v[c] + info->epsilon)) * s[c] + b[c];
    }

    Address_Advance(addr);
  }

  return o;
}
