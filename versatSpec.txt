module Top_Add(){
   VRead inputs_0;
   VRead inputs_1;
   VWrite output;
   F_Add adder;
#
   {inputs_0,inputs_1} -> adder:0..1;
   adder -> output;
##
   config Linear(addr: Address,size){
      for x 0..size {
         inputs_0 = addr[x];
      }
   }

   config Broadcast(addr: Address,size,enable){
      for x 0..size { 
         inputs_1 = addr[x * enable];
      }
   }

   config Output(addr: Address,size){
      for x 0..size {
         output = addr[x];
      }
   }   
}

module Top_Relu(){
   VRead input;
   VWrite output;
   Relu relu;
#
   input -> relu;
   relu -> output;
##
   config Simple(inAddr: Address,outAddr: Address,size){
      for x 0..size {
         input = inAddr[x];
         output = outAddr[x];
      }
   }
}

module Top_Maxpool(){
   VRead features;
   F_AccumMax accum;
   VWrite output;
#   
   features -> accum;
   accum -> output;
##
   config Features(addr: Address,startX,startY,startOffset,kernelW,kernelH,imageWidth,sizeW,sizeH,strideW,strideH){
      for y  0..sizeH {
         for x  0..sizeW {
            for ky 0..kernelH {
               for kx 0..kernelW {
                  features = addr[startOffset + (y * strideH + startY + ky) * imageWidth + x * strideW + startX + kx];
               }
            }
         }
      }
   }

   config Output(addr: Address,startX,startY,startOffset,sizeW,sizeH,outputImageW,stride){
      for y 0..sizeH {
         for x 0..sizeW {
            output = addr[((y + startY) * outputImageW + (x + startX) + startOffset) / stride];
         }
      }
   }
}

module Top_AveragePool(){
   VRead features;
   MyFloatAccum averagePool_accum;
   F_Mul inversedDiv; // Easier to multiply by (1/divisor) than to bring a div unit.
   Const invertedDivisor;
   VWrite output;
#   
   features -> averagePool_accum;
   {averagePool_accum,invertedDivisor} -> inversedDiv:0..1;
   inversedDiv -> output;
##
   config Features(addr: Address,startX,startY,startOffset,kernelW,kernelH,imageWidth,sizeW,sizeH,strideW,strideH){
      for y  0..sizeH {
         for x  0..sizeW {
            for ky 0..kernelH {
               for kx 0..kernelW {
                  features = addr[startOffset + (y * strideH + startY + ky) * imageWidth + x * strideW + startX + kx];
               }
            }
         }
      }
   }

   config Output(addr: Address,startX,startY,startOffset,sizeW,sizeH,outputImageW,stride){
      for y 0..sizeH {
         for x 0..sizeW {
            output = addr[((y + startY) * outputImageW + (x + startX) + startOffset) / stride];
         }
      }
   }
}

module Top_Conv(){
   VRead #(.ADDR_W(18)) features;
   VRead #(.ADDR_W(18)) weights;
   VRead bias;
   F_Mul muller;
   F_Add addBias;
   MyFloatAccum myAccum;
   VWrite output;
#   
   {weights,features} -> muller:0..1;
   muller -> myAccum;

   {myAccum,bias} -> addBias:0..1;
   addBias -> output;
##
   config FeaturesWeightsOutputs(inputX : Address,inputW : Address,outAddr : Address,
      actualKernelW : Fixed,actualKernelH : Fixed,sizeC : Fixed,
      outputH : Dyn,outputW : Dyn,featuresAmount : Dyn,

      startX,startY,
      kernelStartX,kernelStartY,
      startD,outStartX,
      outStartY,
      inputImageW,inputImageC,
      startC,
      kernelW,kernelH,
      outputWidth,stride,outputChannels){

      for d 0..featuresAmount {
         for c 0..sizeC {
            for ky 0..actualKernelH {
               for kx 0..actualKernelW { 
                  features = inputX[(startY + ky) * inputImageW * inputImageC + (startX + kx) * inputImageC + (c + startC)];
                  weights = inputW[(d + startD) * inputImageC * kernelW * kernelH + (c + startC) * kernelW * kernelH + (ky + kernelStartY) * kernelW + (kx + kernelStartX)];
               }
            }
         }
      }
      for y 0..outputH {
         for x 0..outputW {
            for c 0..featuresAmount {
              output = outAddr[((y + outStartY) * outputWidth * outputChannels + (x + outStartX) * outputChannels + startD + c) / stride];
            }
         }
      }
   }

   config Bias(addr : Address,size,stride){
      for x 0..size {
         bias = addr[x / stride];
      }
   }

}

module Top_MatMul(){
   VRead leftRow;
   VRead rightRow;
   F_Mul mat_muller;
   MyFloatAccum myAccum;
   VWrite output;
#
   {leftRow,rightRow} -> mat_muller:0..1;
   mat_muller -> myAccum;
   myAccum -> output;
##
   config Simple(leftAddr: Address,rightAddr: Address,size: Dyn){
      for x 0..size {
         leftRow = leftAddr[x];
         rightRow = rightAddr[x];
      }
   }   

   config Output(addr: Address,size,stride){
      for x 0..size {
         output = addr[x / stride];
      }
   }
}

module Top_BatchNormalization(){
   VRead x;
   VWrite o;

   Const A;
   Const B;

   F_Mul mul;
   F_Add add;
#
   {x,A} -> mul:0..1;
   {mul,B} -> add:0..1;

   add -> o;
##
   config Simple(input : Address,output : Address,index,size : Dyn,aVal,bVal) {
      A.constant = aVal;
      B.constant = bVal;
      for i 0..size {
         x = input[index + i];
         o = output[index + i];
      }
   }
}

merge Test = Top_Add | Top_Relu | Top_Maxpool | Top_Conv | Top_AveragePool | Top_MatMul | Top_BatchNormalization;
